class CalendarsController < ApplicationController
  @@exp_selected = nil

  def index
    @sem_start   = Setting.getSetting('sem_start', 'date')
    @sem_end     = Setting.getSetting('sem_end', 'date')
    @break_start = Setting.getSetting('break_start', 'date')
    @break_end   = Setting.getSetting('break_end', 'date')

    begin
      # Check if no error occurs
      if not params[:error].blank?
        raise
      end
      if @sem_start.blank? || @sem_end.blank? || @break_start.blank? || @break_end.blank?
        raise
      end
      
      # @experiments
      @experiments = Experiment.all
      # display notice of experiment name of selected
      if not @@exp_selected.nil?
        exps = Experiment.find_by_id(@@exp_selected)
        if not exps.nil?
          @display_experiment = "Selected Experiment: " << exps.name
        else
          raise "No such experiment!"
        end

        # @dates is used to store the calendar
        @dates = Array.new
        current_row = Array.new
        @dates << current_row

        # Put blank before the sem start
        for i in 0 .. @sem_start.wday - 1
          current_row << ["-", "disabled"]
        end
        for i in @sem_start .. @sem_end
          if current_row.length >= 7
            current_row = Array.new
            @dates << current_row
          end
          if (i <=> @break_start) >= 0 && (i <=> @break_end) <= 0
            current_row << [i.to_s, "disabled"]
          else
            if Calendar.isAvailableExp(@@exp_selected, i)
              current_row << [i.to_s, "available"]
            else
              current_row << [i.to_s, "unavailable"]
            end
          end
        end
        while current_row.length < 7
          current_row << ["-", "disabled"]
        end
      else
        @display_experiment = 'Please select experiment!'
        @dates = nil
      end
      
    rescue
      @calendar_error = "Unable to generate the calendar."
    end
    
    respond_to do |format|
      format.html # index.html.erb
      format.xml  { render :xml => @experiments }
    end
  end

  def update_calendar
    begin
      # Check if all input fields are given
      if params[:sem_start].blank?
        raise 'No semester starting date is given'
      end
      if params[:sem_end].blank?
        raise 'No semester ending date is given'
      end
      if params[:break_start].blank?
        raise 'No semester break starting date is given'
      end
      if params[:break_end].blank?
        raise 'No semester break ending date is given'
      end
      
      # Parsing dates
      # Exception will be generated by the parse function
      sem_start = Date.parse(params[:sem_start])
      sem_end = Date.parse(params[:sem_end])
      break_start = Date.parse(params[:break_start])
      break_end = Date.parse(params[:break_end])
      
      # Check if the dates are in valid range
      if (sem_start <=> sem_end) >= 0
        raise 'Semester starting date should be before the semester ending date'
      end
      if (break_start <=> break_end) >= 0
        raise 'Semester break starting date should be before the semester break ending date'
      end
      if ((sem_start <=> break_start) >= 0) || ((sem_end <=> break_end) <= 0)
        raise 'Semester break is not in between the semester start and end date'
      end
      if sem_end - sem_start > 366
        raise 'Time between semester start and end date is too big'
      end
      
      # Save the date
      if not Setting.setSetting('sem_start', 'date', sem_start)
        raise 'Unable to save the semester starting date'
      end
      if not Setting.setSetting('sem_end', 'date', sem_end)
        raise 'Unable to save the semester ending date'
      end
      if not Setting.setSetting('break_start', 'date', break_start)
        raise 'Unable to save the semester break starting date'
      end
      if not Setting.setSetting('break_end', 'date', break_end)
        raise 'Unable to save the semester break ending date'
      end
      
      # Clear the calendar availability
      Calendar.delete_all
      Setting.setSetting('sunday', 'integer', 0)
      Setting.setSetting('monday', 'integer', 0)
      Setting.setSetting('tuesday', 'integer', 0)
      Setting.setSetting('wednesday', 'integer', 0)
      Setting.setSetting('thursday', 'integer', 0)
      Setting.setSetting('friday', 'integer', 0)
      Setting.setSetting('saturday', 'integer', 0)

      redirect_to :action => 'index', :notice => 'Calendar was successfully updated.'

      rescue Exception => e
      redirect_to :action => 'index', :error => e.message
    end
  end
  
  def toggle_calendar
    begin
      notice = 'Calendar was successfully updated.'

      if not params[:column].blank?
        sem_start   = Setting.getSetting('sem_start', 'date')
        sem_end     = Setting.getSetting('sem_end', 'date')
        break_start = Setting.getSetting('break_start', 'date')
        break_end   = Setting.getSetting('break_end', 'date')
        
        # Convert the day to number
        day = 0
        case params[:column]
          when 'sunday'
            day = 0
          when 'monday'
            day = 1
          when 'tuesday'
            day = 2
          when 'wednesday'
            day = 3
          when 'thursday'
            day = 4
          when 'friday'
            day = 5
          when 'saturday'
            day = 6
          else
            raise
        end
        
        # Get the last toggle value
        toggleOn = Setting.getSetting(params[:column], 'integer')
        if toggleOn.blank?
          toggleOn = true
        else
          toggleOn = (not (toggleOn > 0)) # flip the toggle value
        end
        Setting.setSetting(params[:column], 'integer', toggleOn)
        # when multiple days are selected, toggles them
        current_date = sem_start
        while current_date.wday != day
          current_date = current_date + 1
        end

        while (current_date <=> sem_end) <= 0
          if ((current_date <=> break_start) < 0) || ((current_date <=> break_end) > 0)
            if not @@exp_selected.nil?
              if Calendar.isAvailableExp(@@exp_selected, current_date)
                # record exists, distroy existing record.
                Calendar.setAvailable(@@exp_selected, current_date, false)
              else
                # new record, add to databse.
                Calendar.setAvailable(@@exp_selected, current_date, true)
              end
            end 
          end
          current_date = current_date + 7
        end
        
        # toggles for specific day
      elsif not params[:date].blank?
        date = Date.parse(params[:date])
        
        # Check the date is valid
        sem_start   = Setting.getSetting('sem_start', 'date')
        sem_end     = Setting.getSetting('sem_end', 'date')
        break_start = Setting.getSetting('break_start', 'date')
        break_end   = Setting.getSetting('break_end', 'date')
        if (date <=> sem_start) < 0 || (date <=> sem_end) > 0
          raise 'The given date is not in this semester.'
        end
        if (date <=> break_start) >= 0 && (date <=> break_end) <= 0
          raise 'The given date is fall in between the semester break.'
        end
        
        # Toggle the availability
        if not @@exp_selected.nil?
          if Calendar.isAvailableExp(@@exp_selected, date)
            # record exists, distroy existing record.
            Calendar.setAvailable(@@exp_selected, date, false)
          else
            # new record, add to databse.
            Calendar.setAvailable(@@exp_selected, date, true)
          end
        end
      end

      redirect_to :action => 'index', :notice => notice
      
    rescue Exception => e
      redirect_to :action => 'index', :error => e.message
    end
  end

  # Post request called when form submitted
  def update_experiment
    begin
      # If successfully post request made
      if request.post?
        # array of post request result
        @@exp_selected = params[:exp_sel]
        # Redirect to index.html.erb with string of experiments
        redirect_to :action => 'index', :notice => 'Experiments Selected'
      else
        # Failed to retrieve request
        redirect_to :action => 'index', :error => 'Failed request'
      end 
    end
  end

end
